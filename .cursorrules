# Project-specific Rules

- **Never modify core or plugins**: Never modify WordPress core files (`wp-admin/`, `wp-includes/`) or third-party plugin files.
- **No JSX syntax**: Do not use JSX in JavaScript files. This theme does not use a build process to transpile JSX. Use `wp.element.createElement()` for creating React elements in WordPress block editor scripts.
- **No build processes**: Do not implement build tools or processes for JavaScript or CSS (no webpack, babel, npm scripts, etc.). Write vanilla JavaScript and CSS that works directly without compilation or bundling.

---

# Code Improvement Documentation Rule

**IMPORTANT:** Whenever you improve code quality, refactor, or apply patterns from this document, you MUST add the improvement pattern to `.cursorrules` if it's not already documented. This ensures knowledge is preserved and patterns can be reused.

- If you extract constants, add the pattern to "Constants & Configuration"
- If you create helper functions, add to "Function & Method Improvements"
- If you simplify conditionals, add to "Conditional Logic Simplifications"
- If you use array-based approaches, add to the appropriate section
- Always include before/after examples when adding new patterns
- **Generalize examples**: Use generic names, values, and identifiers instead of project-specific ones (e.g., use `setting_1`, `default_value` instead of `accent_color_1`, `#FFA843`)

---

# Code-Creation Process

When implementing a new feature or functionality:

1. **Research First**: Before implementing, search the codebase and research multiple implementation approaches. Consider:
   - WordPress-specific APIs and hooks available
   - Existing patterns and conventions in the codebase
   - Different architectural approaches (hooks vs direct calls, filters vs actions, etc.)
   - Performance implications
   - Maintainability and extensibility

2. **Present Options**: After research, present the user with:
   - Multiple viable implementation approaches (typically 2-3 options)
   - Brief pros/cons for each approach
   - Recommendation if one approach is clearly superior

3. **Ask Clarifying Questions**: Before proceeding with implementation, ask questions to understand:
   - User's specific requirements and constraints
   - Expected behavior and edge cases
   - Integration points with existing code
   - Performance or scalability concerns
   - Future extensibility needs

4. **Wait for Approval**: Do not proceed with implementation until the user has:
   - Selected an approach from the options presented
   - Answered any critical clarifying questions
   - Confirmed they're ready to proceed

---

# Key Principles

1. **DRY (Don't Repeat Yourself)**: Consolidate duplicate logic
2. **KISS (Keep It Simple, Stupid)**: Remove unnecessary abstractions
3. **YAGNI (You Aren't Gonna Need It)**: Remove unused features
4. **Single Responsibility**: Each function has one clear purpose
5. **Early Returns**: Reduced nesting, clearer flow
6. **Modern JavaScript**: Use ES6+ features consistently
7. **WordPress Best Practices**: Leverage native functions
8. **Security First**: Strict validation, defense in depth
9. **Scalable Architecture**: Patterns that make adding features easy

---

# Quick Reference: Common Patterns

## Extract Magic Numbers to Constants
```php
// Before
if ( $count >= 3 ) { }
wp_enqueue_script( 'script', $url, $deps, '1.0.0', true );

// After
private const RATE_LIMIT = 3;
private const VERSION = '1.0.0';
if ( $count >= self::RATE_LIMIT ) { }
wp_enqueue_script( 'script', $url, $deps, self::VERSION, true );
```

## Simplify Conditional Returns
```php
// Before
if ( empty( $text ) ) {
    return false;
}
return strpos( $text, 'http' ) !== false;

// After
return ! empty( $text ) && strpos( $text, 'http' ) !== false;
```

## Extract Repeated Values
```php
// Before
wp_enqueue_style( 'style', $url, array(), wp_get_theme()->get( 'Version' ) );
wp_enqueue_script( 'script', $url, array(), wp_get_theme()->get( 'Version' ), true );

// After
$version = wp_get_theme()->get( 'Version' );
wp_enqueue_style( 'style', $url, array(), $version );
wp_enqueue_script( 'script', $url, array(), $version, true );
```

## Combine Early Returns
```php
// Before
if ( ! isset( $attrs ) ) return;
if ( ! isset( $attrs['key'] ) ) return;
if ( ! $attrs['key'] ) return;

// After
if ( ! isset( $attrs['key'] ) || ! $attrs['key'] ) return;
```

---

# Code Quality Standards

## Remove Unnecessary Code

- **Unused code**: Remove variables, functions, attributes, and data attributes that are defined but never used
- **Dead code**: Remove code that cannot execute due to context limitations (e.g., Customizer API code on non-customizer screens)
- **Unnecessary dependencies**: Only include script/style dependencies that are actually used
- **Redundant functionality**: Don't duplicate functionality already provided elsewhere (e.g., inline styles + JavaScript, localized data + inline scripts)
- **Dead code paths**: Remove unreachable else/elseif branches and simplify always-true/false conditionals
- **Remove redundant checks**: Eliminate unnecessary conditionals and type checks when code is already safe
- **Variable elimination**: Remove intermediate variables when values are only used once

## Readability and Maintainability

- **DRY principle**: Extract duplicate HTML/code into shared functions
- **Inline simple functions**: Inline functions that are only called once or are very simple
- **Avoid excessive nesting**: Limit nesting depth (prefer early returns, extract functions, use guard clauses). Refactor deeply nested conditionals or loops into separate functions.
- **Combine similar operations**: Merge multiple similar queries or operations into single statements
- **Condense function calls**: Single-line formatting for simple function calls

---

# PHP Patterns

## Conditional Logic
Use null coalescing and concise conditionals:
- ✅ `$value = $attributes['key'] ?? 'default';`
- ✅ `$has_feature = ( $post && has_block( 'namespace/block', $post ) ) || is_page_template( 'custom-template.php' );`
- ❌ Verbose if/else chains for simple defaults

## Template Rendering
Direct attribute access and inline conditionals:
- ✅ `$attributes['key'] ?? 'default'`
- ✅ `<?php if ( $show ) : ?>`

## Validation Logic
Combine related validations into single statements:
- ✅ `if ( empty( $name ) || empty( $email ) || ! is_email( $email ) || empty( $message ) )`

## Constants & Configuration
- **Extract Magic Numbers**: Replace hardcoded values with named constants
  - Rate limits: `private const RATE_LIMIT = 3;`
  - Versions: `private const VERSION = '1.0.0';`
  - Timeouts: `private const TIMEOUT = 30;`
- **Extract Repeated Function Calls**: Cache expensive or repeated function results
- **Centralized Configuration**: Single source of truth for feature definitions
- **Extract Default Values to Constants**: Group related defaults into constant arrays
  ```php
  // Before: Hardcoded defaults scattered throughout code
  $value1 = get_theme_mod( 'setting_1', 'default_value_1' );
  $value2 = get_theme_mod( 'setting_2', 'default_value_2' );

  // After: Centralized defaults
  private const DEFAULT_VALUES = array(
      'setting_1' => 'default_value_1',
      'setting_2' => 'default_value_2',
  );
  $value1 = get_theme_mod( 'setting_1', self::DEFAULT_VALUES['setting_1'] );
  ```

## Conditional Logic Simplifications
- **Combine Early Returns**: Merge multiple early return conditions
- **Simplify Boolean Checks**: Use direct boolean checks instead of `empty()` when appropriate
- **Ternary for Simple Conditionals**: Use ternary for single-value conditionals
  ```php
  // Before
  if ( ! empty( $email ) && is_email( $email ) ) {
      return $email;
  }
  return get_option( 'admin_email' );

  // After
  return ! empty( $email ) && is_email( $email ) ? $email : get_option( 'admin_email' );
  ```
- **Array-Based Feature Checking**: Use arrays to check multiple features
- **Array-Based Control Registration**: Use arrays to register multiple similar controls
  ```php
  // Before: Repeated code for each control
  $wp_customize->add_setting( 'setting_1', array( 'default' => 'default_1', ... ) );
  $wp_customize->add_control( 'setting_1', array( 'label' => __( 'Setting 1', 'textdomain' ), ... ) );
  $wp_customize->add_setting( 'setting_2', array( 'default' => 'default_2', ... ) );
  $wp_customize->add_control( 'setting_2', array( 'label' => __( 'Setting 2', 'textdomain' ), ... ) );

  // After: Array-based approach
  $controls = array(
      'setting_1' => __( 'Setting 1', 'textdomain' ),
      'setting_2' => __( 'Setting 2', 'textdomain' ),
  );
  foreach ( $controls as $setting_id => $label ) {
      $this->register_control( $wp_customize, $setting_id, $label, 'section_name' );
  }
  ```

## Function & Method Improvements
- **Inline Single-Use Functions**: Remove abstraction when function is used only once
- **Extract Reusable Helpers**: Create helpers for repeated patterns
  ```php
  // Before: Repeated pattern
  $wp_customize->add_setting( 'setting_1', array( 'default' => 'default_1', 'sanitize_callback' => 'sanitize_text_field' ) );
  $wp_customize->add_control( 'setting_1', array( 'label' => __( 'Setting 1', 'textdomain' ), 'section' => 'section_name', 'type' => 'text' ) );
  // ... repeated for each control

  // After: Helper method
  private function register_control( $wp_customize, $setting_id, $label, $section ) {
      $wp_customize->add_setting( $setting_id, array( 'default' => self::DEFAULTS[ $setting_id ], 'sanitize_callback' => 'sanitize_text_field' ) );
      $wp_customize->add_control( $setting_id, array( 'label' => $label, 'section' => $section, 'type' => 'text' ) );
  }
  ```
- **Unified Parameter Functions**: Combine similar functions into one
- **Single-Pass Processing**: Build output directly instead of intermediate arrays

## Code Organization
- **Section Headers**: Use visual separators to group related functionality
  ```php
  // ============================================================================
  // Block Registration
  // ============================================================================
  ```
- **Modular Class Structure**: Break monolithic classes into focused modules

---

# JavaScript Patterns

## Modern Syntax
- **Use const/let**: Prefer `const`/`let` instead of `var`
- **Arrow Functions**: Use arrow functions for callbacks
  ```javascript
  // Before
  addFilter( 'hook', 'namespace', function( settings, name ) { });

  // After
  addFilter( 'hook', 'namespace', ( settings, name ) => { });
  ```
- **Modern String Methods**: Use `includes()` instead of `indexOf()`
- **Destructure Props**: Extract object properties
- **URLSearchParams**: Use URLSearchParams instead of manual string building

## Event Handling
- **Event Delegation**: Use event delegation
  - ✅ `$(document).on('submit', '.form-selector', function(e) { ... });`
  - ❌ `$(document).ready(function() { $('.form-selector').on('submit', ...); });`

## AJAX & Block Editor
- **AJAX Callbacks**: Simplify success/error handling with ternary operators
- **Block Editor**: Use concise React element creation
  - ✅ `el('div', props, content)` instead of verbose `createElement` calls
  - ✅ Arrow functions: `({ attributes, setAttributes }) => ...`

## Consolidation
- **Consolidate Selectors**: Use single query selectors with appropriate combinators instead of multiple separate queries

---

# Security & Validation

## Input Sanitization
Always sanitize user input using WordPress functions:
- ✅ `sanitize_text_field()` - For single-line text
- ✅ `sanitize_email()` - For email addresses
- ✅ `sanitize_textarea_field()` - For multi-line text
- ✅ `sanitize_url()` - For URLs
- ✅ `esc_url_raw()` - For URLs that will be escaped later

```php
// Before
$name = $_POST['name'];
$email = $_POST['email'];

// After
$name = isset( $_POST['name'] ) ? sanitize_text_field( $_POST['name'] ) : '';
$email = isset( $_POST['email'] ) ? sanitize_email( $_POST['email'] ) : '';
```

## Output Escaping
Always escape output for the appropriate context:
- ✅ `esc_html()` - For HTML content
- ✅ `esc_attr()` - For HTML attributes
- ✅ `esc_url()` - For URLs in attributes/href
- ✅ `esc_js()` - For JavaScript strings
- ✅ `esc_html_e()` - For translatable HTML strings

```php
// Before
<div class="<?php echo $class; ?>"><?php echo $content; ?></div>

// After
<div class="<?php echo esc_attr( $class ); ?>"><?php echo esc_html( $content ); ?></div>
```

## Nonce Verification
Always verify nonces for form submissions and AJAX requests:
```php
// Create nonce
wp_nonce_field( 'action_name', 'nonce_field_name' );
// Or for AJAX
wp_localize_script( 'script', 'data', array( 'nonce' => wp_create_nonce( 'action_name' ) ) );

// Verify nonce
if ( ! isset( $_POST['nonce_field_name'] ) || ! wp_verify_nonce( $_POST['nonce_field_name'], 'action_name' ) ) {
    wp_die( 'Security check failed' );
}
```

## ABSPATH Checks
Always check for `ABSPATH` in included files to prevent direct access:
```php
if ( ! defined( 'ABSPATH' ) ) {
    exit;
}
```

## Email Validation
Always validate email addresses:
```php
// Before
$email = sanitize_email( $_POST['email'] );
if ( ! empty( $email ) ) {
    // use email
}

// After
$email = isset( $_POST['email'] ) ? sanitize_email( $_POST['email'] ) : '';
if ( ! empty( $email ) && is_email( $email ) ) {
    // use email
}
```

## Prevent Header Injection
Check for newlines in user input before using in email headers:
```php
// Before
$headers[] = 'From: ' . $name . ' <' . $email . '>';

// After
if ( strpos( $name, "\n" ) !== false || strpos( $name, "\r" ) !== false ||
     strpos( $email, "\n" ) !== false || strpos( $email, "\r" ) !== false ) {
    return new WP_Error( 'invalid_input', 'Invalid input detected.' );
}
$headers[] = 'From: ' . $name . ' <' . $email . '>';
```

## Rate Limiting
Implement rate limiting for form submissions and API calls using WordPress transients:
```php
private const RATE_LIMIT = 3;
private const RATE_LIMIT_WINDOW = HOUR_IN_SECONDS;

private function check_rate_limit() {
    $ip = $this->get_client_ip();
    $key = 'rate_limit_' . md5( $ip );
    $count = get_transient( $key );

    if ( $count && $count >= self::RATE_LIMIT ) {
        return new WP_Error( 'rate_limit_exceeded', 'Too many requests. Please try again later.' );
    }

    return true;
}

private function increment_rate_limit() {
    $ip = $this->get_client_ip();
    $key = 'rate_limit_' . md5( $ip );
    $count = get_transient( $key );
    set_transient( $key, ( $count ? $count + 1 : 1 ), self::RATE_LIMIT_WINDOW );
}
```

## Strict URL Validation
Use `wp_parse_url()` for proper URL validation instead of string matching:
```php
// Before
if ( strpos( $url, 'example.com' ) === false ) return;

// After
$parsed = wp_parse_url( $url );
if ( ! $parsed || empty( $parsed['host'] ) ) return false;
$host = strtolower( $parsed['host'] );
$allowed_hosts = array( 'example.com', 'www.example.com' );
return in_array( $host, $allowed_hosts, true );
```

## URL Filtering
When filtering URLs from user input, use comprehensive pattern matching:
```php
private function contains_url( $text ) {
    if ( empty( $text ) ) {
        return false;
    }

    $patterns = array(
        '/https?:\/\//i',
        '/www\.\w+/i',
        '/\w+\.(com|org|net|io|co|edu|gov)/i',
    );

    foreach ( $patterns as $pattern ) {
        if ( preg_match( $pattern, $text ) ) {
            return true;
        }
    }

    return false;
}
```

## Permission Checks
Always verify user capabilities for admin functions:
```php
// Before
if ( isset( $_POST['save'] ) ) {
    // save data
}

// After
if ( isset( $_POST['save'] ) && current_user_can( 'edit_posts' ) ) {
    // verify nonce
    // save data
}
```

## Inline Style Security
Avoid direct inline styles with user-controlled data. Use CSS custom properties (CSS variables) with proper escaping:
```php
// Before
<div style="background-image: url('<?php echo esc_url( $url ); ?>');"></div>

// After
<div class="image-container" style="--bg-image: url('<?php echo esc_attr( esc_url( $url ) ); ?>');"></div>
```
Then use the custom property in CSS:
```css
.image-container {
    background-image: var(--bg-image);
}
```

**Why this is safe:** CSS custom properties are properly scoped, and we use `esc_url()` and `esc_attr()` for double escaping. This prevents XSS while avoiding the need for JavaScript.

---

# Performance Optimizations

- **Conditional Script Loading**: Only load scripts when needed
  ```php
  public function enqueue_scripts() {
      if ( ! $this->has_block() ) {
          return;
      }
      // enqueue script
  }
  ```
- **Prevent Duplicate Enqueues**: Check if already enqueued
  ```php
  if ( wp_script_is( 'script-handle', 'enqueued' ) ) {
      return;
  }
  ```
- **Optimize Fetch Frequency**: Only fetch when value changes

---

# Architecture Patterns

- **Extract to Standalone Plugin**: Move theme-specific functionality to plugins when reusable
- **Modular Architecture**: Separate into focused classes instead of monolithic classes
- **Remove Build Dependencies**: Use WordPress globals directly
  ```javascript
  // Before: Requires build step
  import { createElement } from '@wordpress/element';

  // After: Use WordPress globals
  const { createElement: el } = wp.element;
  ```

---

# Documentation Standards

- **Comprehensive Docblocks**: Include purpose, parameters, return types
- **Remove Redundant Comments**: Only comment non-obvious logic
- **File Header Documentation**: Describe file purpose

---

# Decision Guide: When to Apply Which Pattern

## Extract to Constant When:
- Value appears 2+ times
- Value might need to change
- Value has semantic meaning (rate limit, timeout, etc.)

## Simplify Conditional When:
- Multiple early returns checking similar things
- Simple boolean logic can be combined
- Ternary is clearer than if/else for single values

## Extract Helper Function When:
- Pattern repeats 3+ times
- Logic is complex enough to benefit from naming
- Function would be reusable

## Inline Function When:
- Function used only once
- Function adds no clarity
- Abstraction doesn't help understanding

## Use Array-Based Approach When:
- Multiple similar features/attributes
- Features might expand
- Need to iterate over features
- Registering multiple similar controls/settings (WordPress Customizer, meta boxes, etc.)

## Extract Default Values to Constants When:
- Default values appear in multiple places (get_theme_mod, get_option, etc.)
- Defaults are related and form a logical group
- You want a single source of truth for configuration

## Extract to Plugin When:
- Functionality is reusable
- Not theme-specific
- Could be used with other themes
